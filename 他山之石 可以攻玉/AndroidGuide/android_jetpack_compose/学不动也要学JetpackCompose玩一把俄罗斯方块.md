> ÂÖ¨‰ºóÂè∑Ôºö[Â≠óËäÇÊï∞ÁªÑ](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0357ed9ee08d4a5d92af66a72b002169~tplv-k3u1fbpfcp-watermark.image)ÔºåÂ∏åÊúõÂØπ‰Ω†ÊúâÊâÄÂ∏ÆÂä© ü§£ü§£

‰Ω†ÁöÑÁ´•Âπ¥ÊòØÂê¶Êúâ**‰øÑÁΩóÊñØÊñπÂùó**Âë¢ ü§£ü§£ Êú¨ÊñáÂ∞±Êù•‰ªãÁªçÂ¶Ç‰ΩïÈÄöËøá Jetpack Compose ÂÆûÁé∞‰∏Ä‰∏™‰øÑÁΩóÊñØÊñπÂùó ~~

ÂÖàÁúã‰∏ãÊïàÊûúÂõæÔºåÂäüËÉΩËøòÊòØÊå∫ÂÆåÂñÑÁöÑ

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/435ca4b8cfc34a0f81034ea6537442e0~tplv-k3u1fbpfcp-watermark.image)

Â∞±ÊàëËá™Â∑±ÁöÑ‰ΩìÈ™åÊù•ËØ¥Ôºå‰ΩøÁî® Compose ÂºÄÂèëÁöÑÂ∫îÁî®ÊàëÊÑüÂèó‰∏çÂà∞Âíå Android ÂéüÁîüÂºÄÂèë‰πãÈó¥Êúâ‰ªÄ‰πàÊÄßËÉΩÂ∑ÆÂºÇÔºå‰ΩÜ Compose Âú®ÂºÄÂèëÈöæÂ∫¶‰∏ä‰ºö‰ΩéÂæàÂ§ö

Google ÂÆòÁΩë‰∏äÊòØËøô‰πà‰ªãÁªç Compose ÁöÑÔºöJetpack Compose ÊòØÁî®‰∫éÊûÑÂª∫ÂéüÁîüÁïåÈù¢ÁöÑÊñ∞Ê¨æ Android Â∑•ÂÖ∑ÂåÖÔºåÂÆÉÂèØÁÆÄÂåñÂπ∂Âä†Âø´ Android ‰∏äÁöÑÁïåÈù¢ÂºÄÂèëÔºå‰ΩøÁî®Êõ¥Â∞ëÁöÑ‰ª£Á†Å„ÄÅÂº∫Â§ßÁöÑÂ∑•ÂÖ∑ÂíåÁõ¥ËßÇÁöÑ Kotlin APIÔºåÂø´ÈÄüËÆ©Â∫îÁî®ÁîüÂä®ËÄåÁ≤æÂΩ©

ÈïøÊúü‰ª•Êù•ÔºåAndroid ÁöÑËßÜÂõæÂ±ÇÊ¨°ÁªìÊûÑÂèØ‰ª•Ë°®Á§∫‰∏∫‰∏Ä‰∏™ËßÜÂõæÊ†ëÔºåËßÜÂõæÊ†ë‰∏≠ÂåÖÂê´ÁùÄËã•Âπ≤‰∏™ View Âíå ViewGroup„ÄÇÂΩìÂ∫îÁî®ÁöÑÊï∞ÊçÆÁî±‰∫éÁî®Êà∑‰∫§‰∫íÁ≠âÂéüÂõ†ËÄåÂèëÁîüÂèòÂåñÊó∂ÔºåÁïåÈù¢ÁöÑÂ±ÇÊ¨°ÁªìÊûÑÂ∞±ÈúÄË¶ÅËøõË°åÊõ¥Êñ∞‰ª•ÊòæÁ§∫ÊúÄÊñ∞Êï∞ÊçÆ„ÄÇÊúÄÂ∏∏ËßÅÁöÑÁïåÈù¢Êõ¥Êñ∞ÊñπÂºèÂ∞±ÊòØ‰ΩøÁî®`findViewById()`Á≠âÂáΩÊï∞ÈÅçÂéÜËßÜÂõæÊ†ëÔºåÂπ∂ÈÄöËøáË∞ÉÁî® `button.setText(String)`„ÄÅ`container.addChild(View)` Êàñ `img.setImageBitmap(Bitmap)` Á≠âÊñπÊ≥ïÊù•ÊîπÂèòÁâπÂÆöËäÇÁÇπÔºåËÄåËøô‰∫õÊñπÊ≥ïÂ∞±‰ºöÊîπÂèò View ÁöÑÂÜÖÈÉ®Áä∂ÊÄÅ„ÄÇ‰ΩÜËøôÁßçÊâãÂä®ÊìçÁ∫µËßÜÂõæÁöÑÊñπÂºèÊèêÈ´ò‰∫ÜÂá∫ÈîôÁöÑÂèØËÉΩÊÄß„ÄÇÂ¶ÇÊûú‰∏ÄÊù°Êï∞ÊçÆÈúÄË¶ÅÂú®Â§ö‰∏™‰ΩçÁΩÆÂëàÁé∞ÔºåÂºÄÂèëËÄÖÂèØËÉΩ‰∏Ä‰∏çÂ∞èÂøÉÂ∞±‰ºöÂøòËÆ∞Êõ¥Êñ∞Êüê‰∏™ÊòæÁ§∫ÂÆÉÁöÑËßÜÂõæ„ÄÇÊ≠§Â§ñÔºåÂΩì‰∏§È°πÊõ¥Êñ∞‰ª•ÊÑèÂ§ñÁöÑÊñπÂºèÂèëÁîüÂÜ≤Á™ÅÊó∂Ôºå‰πüÂæàÂÆπÊòìÈÄ†ÊàêÂºÇÂ∏∏Áä∂ÊÄÅ„ÄÇ‰æãÂ¶ÇÔºåÊüêÈ°πÊõ¥Êñ∞ÂèØËÉΩ‰ºöÂ∞ùËØï‰øÆÊîπÂàöÂàö‰ªéÁïåÈù¢‰∏≠ÁßªÈô§ÁöÑËäÇÁÇπ„ÄÇ‰∏ÄËà¨Êù•ËØ¥ÔºåËΩØ‰ª∂Áª¥Êä§Â§çÊùÇÊÄß‰ºöÈöèÁùÄÈúÄË¶ÅÊõ¥Êñ∞ÁöÑËßÜÂõæÊï∞ÈáèÂ¢ûÂ§öËÄåÂ¢ûÈïø

Âú®ËøáÂéªÁöÑÂá†Âπ¥‰∏≠ÔºåÊï¥‰∏™Ë°å‰∏öÂ∑≤ÂºÄÂßãËΩ¨ÂêëÂ£∞ÊòéÊÄßÁïåÈù¢Ê®°ÂûãÔºåËØ•Ê®°ÂûãÂ§ßÂ§ßÁÆÄÂåñ‰∫Ü‰∏éÊûÑÂª∫ÂíåÊõ¥Êñ∞ÁïåÈù¢ÂÖ≥ËÅîÁöÑÂ∑•Á®ãËÆæËÆ°„ÄÇËØ•ÊäÄÊúØÁöÑÂ∑•‰ΩúÂéüÁêÜÊòØÂú®Ê¶ÇÂøµ‰∏ä‰ªéÂ§¥ÂºÄÂßãÈáçÊñ∞ÁîüÊàêÊï¥‰∏™Â±èÂπïÔºåÁÑ∂Âêé‰ªÖÊâßË°åÂøÖË¶ÅÁöÑÊõ¥Êîπ„ÄÇÊ≠§ÊñπÊ≥ïÂèØÈÅøÂÖçÊâãÂä®Êõ¥Êñ∞ÊúâÁä∂ÊÄÅËßÜÂõæÂ±ÇÊ¨°ÁªìÊûÑÁöÑÂ§çÊùÇÊÄß„ÄÇCompose Â∞±ÊòØ‰∏Ä‰∏™ÈÄÇÁî®‰∫é Android ÁöÑÊñ∞ÂºèÂ£∞ÊòéÊÄßÁïåÈù¢Â∑•ÂÖ∑ÂåÖÔºå**Êèê‰æõ‰∫ÜÂ£∞ÊòéÊÄß APIÔºåËÆ©ÂºÄÂèëËÄÖÂèØÂú®‰∏ç‰ª•ÂëΩ‰ª§ÊñπÂºèÊîπÂèòÂâçÁ´ØËßÜÂõæÁöÑÊÉÖÂÜµ‰∏ãÂëàÁé∞Â∫îÁî®ÁïåÈù¢Ôºå‰ªéËÄå‰ΩøÁºñÂÜôÂíåÁª¥Êä§Â∫îÁî®ÁïåÈù¢ÂèòÂæóÊõ¥Âä†ÂÆπÊòì**

### ÂèØÁªÑÂêàÂáΩÊï∞

Compose ÁöÑÈáçÁÇπÂ∞±Âú®‰∫é `@Composable`ÂáΩÊï∞ÔºåÂç≥**ÂèØÁªÑÂêàÂáΩÊï∞**ÔºåÊØè‰∏™ÂèØÁªÑÂêàÂáΩÊï∞ÂèØ‰ª•Êé•Êî∂Ëã•Âπ≤ÂÖ•ÂèÇÂèÇÊï∞Áî®‰∫éÂèÇ‰∏éËßÜÂõæÁªìÊûÑÁöÑÁªòÂà∂ËØ¥ÊòéÔºå‰ΩÜÂáΩÊï∞‰∏çËøîÂõû‰ªª‰ΩïÂÄº„ÄÇÂèØÁªÑÂêàÂáΩÊï∞Âè™Áî®‰∫éÊèèËø∞ËßÜÂõæÁªìÊûÑÂ¶Ç‰ΩïÁªòÂà∂‰ª•ÂèäÂ¶Ç‰Ωï‰∏éÁî®Êà∑ËøõË°å‰∫§‰∫íÔºå‰ΩÜ‰∏çÈúÄË¶ÅËøîÂõûËßÜÂõæÂØπË±°ÔºåËÄåÊòØÁî± Compose Ê†πÊçÆÂºÄÂèëËÄÖÁöÑÊèèËø∞Êù•ÁîüÊàêÂÖ∑‰ΩìÁöÑËßÜÂõæÂØπË±°

Êú¨Ê∏∏ÊàèÁöÑ icon Â∞±ÊòØÈÄöËøáËøôÁßçÊñπÂºèÊù•ÁîüÊàêÁöÑ„ÄÇÂèØ‰ª•ÁúãÂà∞ `PreviewTetrisIcon()` ÂáΩÊï∞Âπ∂‰∏çÂåÖÂê´ËøîÂõûÂÄºÔºåÂΩìÁÑ∂ËøôÁßçÊÉÖÂÜµ‰∏ã‰πü‰∏çÈúÄË¶ÅÂÖ•ÂèÇÂèÇÊï∞„ÄÇÊ≠§Â§ñÔºåCompose ÁöÑ‰∏Ä‰∏™‰ºòÁÇπÂ∞±ÊòØÊâÄËßÅÂç≥ÊâÄÂæóÔºåÈÄöËøáÊ∑ªÂä† `@Preview` Ê≥®Ëß£Â∞±ÂèØ‰ª•È¢ÑËßàÂÆûÁé∞ÊïàÊûúÔºåÊØèÊ¨°‰øÆÊîπËøáÂêéÊó†ÈúÄÁºñËØëÔºåÂè™Ë¶ÅÂà∑Êñ∞‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•ÁúãÂà∞‰øÆÊîπÁªìÊûú

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3eb95559cba41339edb61c268aec9fc~tplv-k3u1fbpfcp-watermark.image)

Compose ÊòØ‰∏Ä‰∏™Â£∞ÊòéÊÄßÁïåÈù¢Ê°ÜÊû∂ÔºåËøôÊú¨Ë∫´‰πüÂ∏¶Êúâ‰∏ÄÁÇπ**ÁªÑÂêà**ÁöÑÊÑèÂë≥„ÄÇÊØè‰∏™ËßÜÂõæÁªìÁÇπÂùáÈÄöËøáÂáΩÊï∞ÁöÑÂΩ¢ÂºèÊù•ËøõË°åÂ£∞ÊòéÔºåÈÇ£‰πàÊàë‰ª¨Ëá™ÁÑ∂‰πüÂèØ‰ª•Â∞ÜÊØè‰∏™ËßÜÂõæÁªìÁÇπÂùáÂ£∞Êòé‰∏∫‰∏Ä‰∏™‰∏™ÂáΩÊï∞ÔºåÁÑ∂ÂêéÂ∞ÜÊØè‰∏™ÂáΩÊï∞‰Ωú‰∏∫ÊúÄÁªàËßÜÂõæÊ†ëÂáΩÊï∞ÁöÑÂÖ•ÂèÇÂèÇÊï∞Êù•ËøõË°åÁªÑÂêà

‰ª•Êú¨Ê∏∏Êàè‰∏∫‰æãÔºåÊï¥‰∏™Ê∏∏ÊàèÂè™ÂåÖÂê´‰∏Ä‰∏™È°µÈù¢ÔºåÈ°µÈù¢ÂèØ‰ª•ÂÜçÁªÜÂàÜ‰∏∫‰∏â‰∏™ËäÇÁÇπÔºöÊ∏∏ÊàèÊú∫Ë∫´ÔºàTetrisBodyÔºâ„ÄÅÊ∏∏ÊàèÂ±èÂπïÔºàTetrisScreenÔºâ„ÄÅÊ∏∏ÊàèÊåâÈíÆÔºàTetrisButtonÔºâ

TetrisBody ÂáΩÊï∞Â∞±ÂåÖÂê´‰∏§‰∏™ÂÖ•ÂèÇÂèÇÊï∞Áî®‰∫éÂÆπÁ∫≥ TetrisScreen Âíå TetrisButton

```kotlin
@Composable
fun TetrisBody(
    tetrisScreen: @Composable (() -> Unit),
    tetrisButton: @Composable (() -> Unit),
)
```

### Ê∏∏ÊàèÊú∫Ë∫´ - TetrisBody

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d9edfd61e954556b743cc4c725f01a4~tplv-k3u1fbpfcp-watermark.image)

TetrisBody ÊØîËæÉÁÆÄÂçïÔºåÈúÄË¶ÅÂÆûÁé∞ÁöÑÂäüËÉΩÊúâ‰∏â‰∏™Ôºö

- ÁªòÂà∂ËÉåÊôØËâ≤
- ‰∏∫ TetrisScreen Âíå TetrisButton È¢ÑÁïô‰ΩçÁΩÆ
- ‰∏∫ TetrisScreen ÁªòÂà∂Èò¥ÂΩ±ËæπÊ°Ü

```kotlin
@Composable
fun TetrisBody(
    tetrisScreen: @Composable (() -> Unit),
    tetrisButton: @Composable (() -> Unit),
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(color = BodyBackground)
            .padding(bottom = 30.dp)
    ) {
        Box(
            Modifier
                .align(alignment = Alignment.CenterHorizontally)
                .fillMaxWidth()
                .weight(weight = 1f)
                .padding(start = 40.dp, top = 50.dp, end = 40.dp, bottom = 10.dp),
        ) {

            //ÁªòÂà∂Ê∏∏ÊàèÂ±èÂπïÁöÑËæπÊ°Ü
            val borderPadding = 8.dp
            Canvas(modifier = Modifier.fillMaxSize()) {
                drawScreenBorder(
                    leftTop = Offset(x = 0f, y = 0f),
                    width = size.width,
                    height = size.height,
                    borderPadding = borderPadding,
                )
            }

            //Ê∏∏ÊàèÂ±èÂπï
            Row(
                modifier = Modifier
                    .matchParentSize()
                    .padding(all = borderPadding)
            ) {
                tetrisScreen()
            }
        }

        //Ê∏∏ÊàèÊåâÈíÆ
        tetrisButton()
    }
}
```

### Ê∏∏ÊàèÊåâÈíÆ - TetrisButton

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7c28153d4044dde9d47a9254f355d2c~tplv-k3u1fbpfcp-watermark.image)

TetrisButton ‰πüÂæàÁÆÄÂçïÔºåÈúÄË¶ÅÂÆûÁé∞ÁöÑÂäüËÉΩÊúâ‰∏§‰∏™Ôºö

- ÁªòÂà∂‰πù‰∏™Êìç‰ΩúÊåâÈíÆ
- ÂêëÂ§ñÈÄè‰º†Áî®Êà∑ÁöÑÁÇπÂáªÊìç‰ΩúÔºåÂØπ‰∫ã‰ª∂Á±ªÂûãËøõË°åÂå∫ÂàÜ

Âõ†Ê≠§ TetrisButton ÂáΩÊï∞Â∞±ÈúÄË¶ÅÂåÖÂê´‰∏Ä‰∏™ÂÖ•ÂèÇÂèÇÊï∞ PlayListener ÂØπË±°ÔºåTetrisButton ÈúÄË¶ÅÊ†πÊçÆÁî®Êà∑ÁÇπÂáª‰∫ÜÂì™‰∏™ÊåâÈíÆÊù•ÂõûË∞É PlayListener Áõ∏Â∫îÁöÑÊñπÊ≥ïÔºåÂêëÂ§ñÈÄè‰º†ÁÇπÂáª‰∫ã‰ª∂

```kotlin
enum class TransformationType {
    Left, Right, Rotate, Down, FastDown, Fall
}

data class PlayListener constructor(
    val onStart: () -> Unit,
    val onPause: () -> Unit,
    val onReset: () -> Unit,
    val onSound: () -> Unit,
    val onTransformation: (TransformationType) -> Unit
)

@Preview(backgroundColor = 0xffefcc19, showBackground = true)
@Composable
fun TetrisButton(
    playListener: PlayListener = combinedPlayListener()
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .wrapContentHeight(),
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight(),
            horizontalArrangement = Arrangement.Center
        ) {
            val controlPadding = 20.dp
            ControlButton(hint = "Start", modifier = Modifier.padding(end = controlPadding)) {
                playListener.onStart()
            }
            ControlButton(
                hint = "Pause",
                modifier = Modifier.padding(start = controlPadding, end = controlPadding)
            ) {
                playListener.onPause()
            }
            ControlButton(
                hint = "Reset",
                modifier = Modifier.padding(start = controlPadding, end = controlPadding)
            ) {
                playListener.onReset()
            }
            ControlButton(hint = "Sound", modifier = Modifier.padding(start = controlPadding)) {
                playListener.onSound()
            }
        }
        ConstraintLayout(
            modifier = Modifier
                .padding(top = 20.dp)
                .fillMaxWidth()
                .wrapContentWidth(align = Alignment.CenterHorizontally)
        ) {
            val (leftBtn, rightBtn, fastDownBtn, rotateBtn, fallBtn) = createRefs()
            val innerMargin = 24.dp
            PlayButton(icon = "‚óÄ", modifier = Modifier.constrainAs(leftBtn) {
                start.linkTo(anchor = parent.start)
                top.linkTo(anchor = parent.top)
                end.linkTo(anchor = rightBtn.start, margin = innerMargin)
            }) {
                playListener.onTransformation(Left)
            }
            PlayButton(icon = "‚ñ∂", modifier = Modifier.constrainAs(rightBtn) {
                start.linkTo(anchor = leftBtn.end, margin = innerMargin)
                top.linkTo(anchor = leftBtn.top)
                bottom.linkTo(anchor = leftBtn.bottom)
            }) {
                playListener.onTransformation(Right)
            }
            PlayButton(
                icon = "Rotate",
                fontSize = 18.sp,
                modifier = Modifier.constrainAs(rotateBtn) {
                    top.linkTo(anchor = rightBtn.top)
                    start.linkTo(anchor = rightBtn.end, margin = innerMargin)
                }) {
                playListener.onTransformation(Rotate)
            }
            PlayButton(icon = "‚ñº", modifier = Modifier.constrainAs(fastDownBtn) {
                top.linkTo(anchor = leftBtn.bottom)
                start.linkTo(anchor = leftBtn.start)
                end.linkTo(anchor = rightBtn.end)
            }) {
                playListener.onTransformation(FastDown)
            }
            PlayButton(
                icon = "‚ñº\n‚ñº",
                modifier = Modifier.constrainAs(fallBtn) {
                    top.linkTo(anchor = fastDownBtn.top)
                    start.linkTo(anchor = rightBtn.end)
                    end.linkTo(anchor = rotateBtn.start)
                }) {
                playListener.onTransformation(Fall)
            }
        }
    }

}
```

### Ê∏∏ÊàèÂ±èÂπï  - TetrisScreen

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32b685c86b54b6ead24f9d00e89ed30~tplv-k3u1fbpfcp-watermark.image)

TetrisScreen ÊØîËæÉÂ§çÊùÇÔºåÈúÄË¶ÅÂÆûÁé∞ÁöÑÂäüËÉΩÁÇπ‰∏ªË¶ÅÊúâ‰∫î‰∏™Ôºö

- ÁªòÂà∂Ê∏∏ÊàèÂ±èÂπïËÉåÊôØ
- ÁªòÂà∂‰∏çÊñ≠‰∏ãËêΩÁöÑÊñπÂùó
- ‰∏∫ÊñπÂùóÊèê‰æõÂ∑¶Áßª„ÄÅÂè≥Áßª„ÄÅÂåÄÈÄü‰∏ãÈôç„ÄÅÂä†ÈÄü‰∏ãÈôç„ÄÅÊóãËΩ¨Á≠âÂäüËÉΩ
- ÂΩìÊñπÂùóÊó†Ê≥ïÂÜç‰∏ãËêΩÊó∂ÔºåÊ†πÊçÆÈúÄË¶ÅÂÜ≥ÂÆöÊòØÂê¶ËøõË°åÊ∂àË°åÔºåÁÑ∂Âêé‰øùÂ≠òËØ•ÊñπÂùóÁöÑÂùêÊ†á‰ø°ÊÅØÂà∞Â±èÂπïËÉåÊôØ‰∏≠ÔºåÊ†πÊçÆÂùêÊ†á‰ø°ÊÅØÁªòÂà∂ÂÆûÂøÉÊñπÂùóÔºåÁÑ∂ÂêéÁîüÊàêÊñ∞ÁöÑÊñπÂùóÔºåÈáçÂ§çÁ¨¨‰∫å‰∏™Ê≠•È™§
- ÂΩìÊñπÂùóÊó†Ê≥ïÂÜç‰∏ãËêΩÊó∂ÔºåÂ¶ÇÊûúÊñπÂùóË∂ÖÂá∫ÂΩìÂâçÂ±èÂπïÔºåÂàôÁªìÊùüÊ∏∏ÊàèÔºåÊâßË°åÊ∏ÖÂ±èÂä®Áîª

Compose ÊòØÊ†πÊçÆÂáΩÊï∞ÁöÑÂÖ•ÂèÇÂèÇÊï∞ÊòØÂê¶ÂèëÁîü‰∫ÜÂèòÂåñÊù•ÂÜ≥ÂÆöÊòØÂê¶ÈúÄË¶ÅËøõË°åÁïåÈù¢Êõ¥Êñ∞ÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨Âú®ÁªòÂà∂‰∏ãËêΩÁöÑÊñπÂùóÊó∂ÂèØ‰ª•Â∞ÜÊï¥‰∏™È°µÈù¢ËßÜ‰∏∫ÈùôÊÄÅÁöÑÔºå‰ªÖÈúÄË¶ÅÊ†πÊçÆÂΩìÂâçÁöÑÂùêÊ†áÂÄºËøõË°åÁªòÂà∂Âç≥ÂèØÔºåÁÑ∂ÂêéÊØèÈöîÂá†ÁôæÊØ´ÁßíÂ∞±ÊîπÂèòÊñπÂùóÁöÑÂùêÊ†á‰ø°ÊÅØÔºåÁî±Ê≠§ÁîüÊàêÊñ∞ÁöÑÂÖ•ÂèÇÂèÇÊï∞ÔºåÈÄöÁü• Compose ËøõË°åÈ°µÈù¢Êõ¥Êñ∞Âç≥ÂèØ

Êï¥‰∏™Ê∏∏ÊàèÁöÑÊâÄÊúâÁä∂ÊÄÅ‰ø°ÊÅØÈÉΩ‰øùÂ≠òÂú®‰∏Ä‰∏™ TetrisState ÂØπË±°‰∏≠ÔºåCompose Â∞±ÈÄöËøáÁõëÂê¨`State<TetrisState>`‰∏≠ÂÄºÁöÑÂèòÂåñÊù•ÂÜ≥ÂÆöÊòØÂê¶ÈúÄË¶ÅËøõË°åÁïåÈù¢Êõ¥Êñ∞„ÄÇÊï¥‰∏™Ê∏∏ÊàèÂ±èÂπïÂ∞±Ë¢´ÂÆö‰πâ‰∏∫‰∏Ä‰∏™ 10 x 24 ÁöÑ‰∫åÁª¥Êï∞ÁªÑÔºåÂç≥ brickArrayÔºåÂΩìÊï∞ÁªÑÂÄºÁ≠â‰∫é‰∏ÄÊó∂ÔºåÂ∞±ÂØπÂ∫îÂÆûÂøÉÊñπÂùóÔºåÂê¶ÂàôÂ∞±ÊòØÁ©∫ÂøÉÊñπÂùó„ÄÇTetris Â∞±ÂØπÂ∫îÂ§Ñ‰∫é‰∏ãËêΩÁä∂ÊÄÅ‰∏≠ÁöÑÊñπÂùó

```kotlin
data class TetrisState(
    val brickArray: Array<IntArray>, //Â±èÂπïÂùêÊ†áÁ≥ª
    val tetris: Tetris, //‰∏ãËêΩÁöÑÊñπÂùó
    val gameStatus: GameStatus = GameStatus.Welcome, //Ê∏∏ÊàèÁä∂ÊÄÅ
    val soundEnable: Boolean = true, //ÊòØÂê¶ÂºÄÂêØÈü≥Êïà
    val nextTetris: Tetris = Tetris(), //‰∏ã‰∏Ä‰∏™ÊñπÂùó
)
```

ÊñπÂùóÁ±ªÂûã‰∏ÄÂÖ±ÂèØ‰ª•ÂàÜ‰∏∫‰∏ÉÁßçÔºåÁî®Â≠óÊØçË°®Á§∫Â∞±ÂàÜÂà´ÊòØÔºöI„ÄÅS„ÄÅZ„ÄÅL„ÄÅO„ÄÅJ„ÄÅT„ÄÇÊØèÁßçÁ±ªÂûãÈÉΩÂèØ‰ª•ÂÆπÁ∫≥Âú®‰∏Ä‰∏™ 4 x 4 ÁöÑ‰∫åÁª¥Êï∞ÁªÑÈáåÔºå‰∏çÁÆ°ÂÖ∂Â¶Ç‰ΩïÊóãËΩ¨ÔºåÈÉΩ‰∏ç‰ºöË∂ÖÂá∫Ëøô‰∏™ËåÉÂõ¥„ÄÇÂèØ‰ª•Áî®‰ª•‰∏ãÊï∞ÁªÑÊù•Êñπ‰æøËÆ∞ÂøÜÊØèÁßçÂèØËÉΩÁöÑÊóãËΩ¨ÁªìÊûú

```kotlin
val mockData = arrayOf(
    arrayOf(//I
        intArrayOf(
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            1, 1, 1, 1
        ),
        intArrayOf(
            0, 1, 0, 0,
            0, 1, 0, 0,
            0, 1, 0, 0,
            0, 1, 0, 0
        )
    ),
    arrayOf(//S
        intArrayOf(
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 1, 1, 0,
            1, 1, 0, 0
        ),
        intArrayOf(
            0, 0, 0, 0,
            1, 0, 0, 0,
            1, 1, 0, 0,
            0, 1, 0, 0
        )
    ),
    arrayOf(//Z
        intArrayOf(
            0, 0, 0, 0,
            0, 0, 0, 0,
            1, 1, 0, 0,
            0, 1, 1, 0
        ),
        intArrayOf(
            0, 0, 0, 0,
            0, 1, 0, 0,
            1, 1, 0, 0,
            1, 0, 0, 0
        )
    ),
    ¬∑¬∑¬∑
)
```

ÊØè‰∏™Â§Ñ‰∫é‰∏ãËêΩÁä∂ÊÄÅÁöÑÊñπÂùóÈÉΩË¢´ÂÆö‰πâ‰∏∫ Tetris ÂØπË±°„ÄÇÂàùÂßãÁä∂ÊÄÅ‰∏ã brickArray ÁöÑÂÄºÈÉΩÁ≠â‰∫é 0ÔºåËÄå Tetris ÁöÑÂàùÂßã‰ΩçÁΩÆÊòØÂú®Â±èÂπï‰πãÂ§ñÁöÑÔºåÊñπÂùóÊØèÊ¨°‰∏ãËêΩÊó∂ÈÉΩÂ∞ÜÊñπÂùóÂú® brickArray ‰∏≠ÁöÑ‰ΩçÁΩÆÁöÑÂùêÊ†áÂÄºÊîπÂèò‰∏∫ 1Ôºå‰ªéËÄåÂÜ≥ÂÆö‰∫ÜÈúÄË¶ÅÂú®Â±èÂπïÁöÑÂì™‰∏™‰ΩçÁΩÆÁªòÂà∂ÂÆûÂøÉÊñπÂùóÔºõÂÜçÈÄöËøáÊîπÂèòÊñπÂùóÁõ∏ÂØπÂ±èÂπïÂ∑¶‰∏äËßíÁöÑÂÅèÁßªÈáè Offset ÁöÑÂÄºÔºå‰ª•Ê≠§ÊîπÂèòÊñπÂùóÁõ∏ÂØπÂ±èÂπïÁöÑ‰ΩçÁΩÆÔºå‰ªéËÄåÂÆûÁé∞ÊñπÂùóÁöÑÂ∑¶Âè≥ÁßªÂä®Âíå‰∏ãËêΩ

```kotlin
data class Location(val x: Int, val y: Int)

data class Tetris constructor(
    val shapes: List<List<Location>>, //Ê≠§ÊñπÂùóÊâÄÊúâÂèØËÉΩÁöÑÊóãËΩ¨ÁªìÊûú
    val type: Int, //Áî®‰∫éÊ†áËÆ∞ÂΩìÂâçÂ§Ñ‰∫éÂì™ÁßçÊóãËΩ¨Áä∂ÊÄÅ
    val offset: Location, //ÊñπÂùóÁõ∏ÂØπÂ±èÂπïÂ∑¶‰∏äËßíÁöÑÂÅèÁßªÈáè
) {

    //Ê≠§ÊñπÂùóÂΩìÂâçÁöÑÂΩ¢Áä∂
    val shape: List<Location>
        get() = shapes[type]
    
}
```

ÁÆÄÂçïËµ∑ËßÅÔºåÂèØ‰ª•‰∫ãÂÖàÂ∞±ÂÆö‰πâÂ•Ω Tetris ÂêÑÁßçÂèØËÉΩÁöÑÊñπÂùóÁ±ªÂûãÔºå‰ª•ÂèäËØ•ÊñπÂùóÁöÑÂêÑÁßçÊóãËΩ¨ÁªìÊûú

```kotlin
		private val allShapes = listOf(
            //I
            listOf(
                listOf(Location(0, 3), Location(1, 3), Location(2, 3), Location(3, 3)),
                listOf(Location(1, 0), Location(1, 1), Location(1, 2), Location(1, 3)),
            ),
            //S
            listOf(
                listOf(Location(0, 3), Location(1, 2), Location(1, 3), Location(2, 2)),
                listOf(Location(0, 1), Location(0, 2), Location(1, 2), Location(1, 3)),
            ),
            //Z
            listOf(
                listOf(Location(0, 2), Location(1, 2), Location(1, 3), Location(2, 3)),
                listOf(Location(0, 2), Location(0, 3), Location(1, 1), Location(1, 2)),
            ),
            //L
            listOf(
                listOf(Location(0, 1), Location(0, 2), Location(0, 3), Location(1, 3)),
                listOf(Location(0, 2), Location(0, 3), Location(1, 2), Location(2, 2)),
                listOf(Location(0, 1), Location(1, 1), Location(1, 2), Location(1, 3)),
                listOf(Location(0, 3), Location(1, 3), Location(2, 3), Location(2, 2)),
            ),
            //O
            listOf(
                listOf(Location(0, 2), Location(0, 3), Location(1, 2), Location(1, 3)),
            ),
            //J
            listOf(
                listOf(Location(0, 3), Location(1, 1), Location(1, 2), Location(1, 3)),
                listOf(Location(0, 2), Location(0, 3), Location(1, 3), Location(2, 3)),
                listOf(Location(0, 1), Location(0, 2), Location(0, 3), Location(1, 1)),
                listOf(Location(0, 2), Location(1, 2), Location(2, 2), Location(2, 3)),
            ),
            //T
            listOf(
                listOf(Location(0, 2), Location(1, 2), Location(2, 2), Location(1, 3)),
                listOf(Location(1, 1), Location(0, 2), Location(1, 2), Location(1, 3)),
                listOf(Location(1, 2), Location(0, 3), Location(1, 3), Location(2, 3)),
                listOf(Location(0, 1), Location(0, 2), Location(0, 3), Location(1, 2)),
            ),
        )
```

‰πãÂêéÂú®ÊØèÊ¨°ÁîüÊàê Tetris ÂØπË±°Êó∂ÔºåÈÉΩÈöèÊú∫‰ªé allShapes ‰∏≠ÂèñÂÄº„ÄÇÂπ∂‰∏îÊØè‰∏™ Tetris ÂØπË±°ÁöÑÂàùÂßãÂÅèÁßªÈáè offset ÁöÑ Y ÂÄºÂõ∫ÂÆöÊòØ -4ÔºåÂç≥ÈªòËÆ§Â§Ñ‰∫éÂ±èÂπï‰πãÂ§ñÔºåÂΩìÊñπÂùó‰∏çÊñ≠ÁßªÂä®Êó∂ÔºåÂÖ∂ Offset Â∞±‰ºöÂèòÊàê `Location(0, -3)`„ÄÅ`Location(1, -2)` .... `Location(2, 10)`Á≠âÂêÑÁßçÂÄºÔºåÈÄöËøáÊîπÂèò X ÂÄºÊù•ÂÆûÁé∞Â∑¶Âè≥ÁßªÂä®„ÄÅÊîπÂèò Y ÂÄºÊù•ÂÆûÁé∞‰∏ãÁßª

```kotlin
        operator fun invoke(): Tetris {
            val shapes = allShapes.random()
            val type = Random.nextInt(0, shapes.size)
            return Tetris(
                shapes = shapes,
                type = type,
                offset = Location(
                    Random.nextInt(
                        0,
                        BRICK_WIDTH - 3
                    ), -4
                )
            )
        }
```

ÊØè‰∏™ÊñπÂùóÂ∞±ÂèØ‰ª•ÈÄöËøá Canvas Êù•ËøõË°åÁªòÂà∂ÔºåÊñπ‰æøËµ∑ËßÅÂ∞±Â∞ÜÂÖ∂ÂÆö‰πâ‰∏∫Êâ©Â±ïÂáΩÊï∞ÔºåÈÄöËøá color Êù•ÊéßÂà∂ÊòØË¶ÅÁªòÂà∂ÂÆûÂøÉÊñπÂùóËøòÊòØËôöÂøÉÊñπÂùó

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb5dd2ddd4bd4d96ad1dad1f4cca753d~tplv-k3u1fbpfcp-watermark.image)

```kotlin
fun DrawScope.drawBrick(brickSize: Float, color: Color) {
    drawRect(color = color, size = Size(brickSize, brickSize))
    val strokeWidth = brickSize / 9f
    translate(left = strokeWidth, top = strokeWidth) {
        drawRect(
            color = ScreenBackground,
            size = Size(
                width = brickSize - 2 * strokeWidth,
                height = brickSize - 2 * strokeWidth
            )
        )
    }
    val brickInnerSize = brickSize / 2.0f
    val translateLeft = (brickSize - brickInnerSize) / 2
    translate(left = translateLeft, top = translateLeft) {
        drawRect(
            color = color,
            size = Size(brickInnerSize, brickInnerSize)
        )
    }
}
```

‰πãÂêéÂè™ÈúÄË¶ÅÈÅçÂéÜ‰ª£Ë°®Êï¥‰∏™Â±èÂπïÂùêÊ†áÂÄºÁöÑ screenMatrix ËøõË°åÁªòÂà∂Â∞±ÂèØ‰ª•ÁªòÂà∂Âá∫Â±èÂπïËÉåÊôØ‰ª•Âèä‰∏ãËêΩÁöÑÊñπÂùóÔºåÂ¶ÇÊûúÂÄºÁ≠â‰∫é‰∏ÄÂ∞±‰ΩøÁî® BrickFill È¢úËâ≤ÔºåÂê¶ÂàôÂ∞±‰ΩøÁî® BrickAlpha„ÄÇÊØèÂΩìÊúâÊñπÂùóÊó†Ê≥ïÁªßÁª≠‰∏ãËêΩÊó∂ÔºåËØ•ÊñπÂùóÊâÄÂú®ÁöÑÂùêÊ†áÂÄºÂ∞±ÈÉΩ‰ºöË¢´ÂÜôÂÖ•Âà∞ screenMatrix ‰∏≠Ôºå‰ª•Ê≠§Êù•‰øùÂ≠òÂêÑ‰∏™Âõ∫ÂÆöÁöÑÂÆûÂøÉÊñπÂùó

```kotlin
	Canvas(
        modifier = Modifier
            .fillMaxSize()
            .background(color = ScreenBackground)
            .padding(
                start = screenPadding, top = screenPadding,
                end = screenPadding, bottom = screenPadding
            )
    ) {
        val width = size.width
        val height = size.height
        val screenPaddingPx = screenPadding.toPx()
        val spiritPaddingPx = spiritPadding.toPx()
        val brickSize = (height - spiritPaddingPx * (matrixHeight - 1)) / matrixHeight

        kotlin.run {
            screenMatrix.forEachIndexed { y, ints ->
                ints.forEachIndexed { x, isFill ->
                    translate(
                        left = x * (brickSize + spiritPaddingPx),
                        top = y * (brickSize + spiritPaddingPx)
                    ) {
                        drawBrick(
                            brickSize = brickSize,
                            color = if (isFill == 1) BrickFill else BrickAlpha
                        )
                    }
                }
            }
        }

        ¬∑¬∑¬∑
    }
```

### Ë∞ÉÂ∫¶Âô® - TetrisViewModel

TetrisViewModel ÊòØÊï¥‰∏™Ê∏∏ÊàèÁöÑË∞ÉÂ∫¶Âô®ÔºåÂÖ∂Â§ß‰ΩìÁªìÊûÑÂ¶Ç‰∏ãÊâÄÁ§∫„ÄÇ`dispatch` ÊñπÊ≥ïË¥üË¥£Êé•Êî∂Â§ñÈÉ®ÁöÑÂêÑ‰∏™‰∫ã‰ª∂Ôºå‰∫ã‰ª∂Á±ªÂûãÂ∞±ÂØπÂ∫îÂØÜÂ∞ÅÁ±ª Action

```kotlin
class TetrisViewModel : ViewModel() {

    companion object {

        private const val DOWN_SPEED = 500L

        private const val CLEAR_SCREEN_SPEED = 30L

    }

    private val _tetrisStateLD: MutableStateFlow<TetrisState> = MutableStateFlow(TetrisState())

    val tetrisStateLD = _tetrisStateLD.asStateFlow()

    private val tetrisState: TetrisState
        get() = _tetrisStateLD.value

    private var downJob: Job? = null

    private var clearScreenJob: Job? = null

    fun dispatch(action: Action) {
        playSound(action)
        val unit = when (action) {
            Action.Welcome, Action.Reset -> {
                ¬∑¬∑¬∑
            }
            Action.Start -> {
                ¬∑¬∑¬∑
            }
            Action.Background, Action.Pause -> {
                ¬∑¬∑¬∑
            }
            Action.Resume -> {

            }
            Action.Sound -> {
                ¬∑¬∑¬∑
            }
            is Action.Transformation -> {
                ¬∑¬∑¬∑
            }
        }
    }
    
    ¬∑¬∑¬∑
    
}

sealed class Action {
    object Welcome : Action()
    object Start : Action()
    object Pause : Action()
    object Reset : Action()
    object Sound : Action()
    object Background : Action()
    object Resume : Action()
    data class Transformation(val transformationType: TransformationType) : Action()
}

enum class TransformationType {
    Left, Right, Rotate, Down, FastDown, Fall
}
```

Ê∏∏ÊàèÁ¨¨‰∏ÄÊ¨°ÂêØÂä®Êó∂ÔºåÁî± MainActivity Êù•‰∏ªÂä®‰∏ãÂèë Action.Welcome ‰∫ã‰ª∂ÔºåÊâßË°åÊ¨¢ËøéÂä®Áîª„ÄÇÂΩìÂêéÁª≠Áî®Êà∑ÁÇπÂáª Start ÊåâÈíÆÂêØÂä®Ê∏∏ÊàèÊó∂ÔºåÂàô‰ºö‰∏ãÂèë Action.Start ‰∫ã‰ª∂Ôºå‰ªéËÄåÂêØÂä®‰∏Ä‰∏™ÊâßË°åÂª∂Êó∂‰ªªÂä°ÁöÑÂçèÁ®ã‰ªªÂä° downJobÔºådownJob Ë¥üË¥£‰∏ãÂèë TransformationType.Down ‰∫ã‰ª∂ÔºåÂç≥ÊñπÂùó‰∏ãËêΩ‰∫ã‰ª∂ÔºåÂΩìÊ∂àËÄó‰∫ÜËØ•‰∫ã‰ª∂ÂêéÔºåÂèà‰ºöÈáçÂ§çË∞ÉÁî® `startDownJob()` ÊñπÊ≥ïÔºå‰ªéËÄåÂÆûÁé∞Ëá™ÊàëÈ©±Âä®ÊñπÂùóÂåÄÈÄü‰∏ãÈôç

```kotlin
    private var downJob: Job? = null

    private fun onStartGame() {
        dispatchState(TetrisState().copy(gameStatus = GameStatus.Running))
        startDownJob()
    }

    private fun startDownJob() {
        cancelDownJob()
        cancelClearScreenJob()
        downJob = viewModelScope.launch {
            delay(DOWN_SPEED)
            dispatch(Action.Transformation(TransformationType.Down))
        }
    }
```

Action.Transformation ‰ª£Ë°®ÁöÑÊòØÂ§öÁßçÊìç‰ΩúË°å‰∏∫Ôºå‰æãÂ¶ÇÂ∑¶Âè≥ÁßªÂä®„ÄÅÊóãËΩ¨Á≠â„ÄÇ‰ΩÜÂπ∂‰∏çÊòØÊØèÁßçÊìç‰ΩúÈÉΩËÉΩÁîüÊïàÔºåÂõ†‰∏∫ÊâßË°åËØ•Êìç‰ΩúÂèØËÉΩ‰ºöÂØºËá¥ÊñπÂùóË∂ÖÂá∫Â±èÂπï„ÄÇÊâÄ‰ª•Â¶ÇÊûú `onTransformation` ÊñπÊ≥ïËøîÂõû null ÁöÑËØùÔºåËØ¥ÊòéÊ≠§Ê¨°Ë°å‰∏∫Êó†ÊïàÔºåÊó†ÈúÄÊõ¥Êñ∞ÁïåÈù¢

```kotlin
fun TetrisState.onTransformation(transformationType: TransformationType): TetrisState {
    return when (transformationType) {
        TransformationType.Left -> {
            onLeft()
        }
        TransformationType.Right -> {
            onRight()
        }
        TransformationType.Down -> {
            onDown()
        }
        TransformationType.FastDown -> {
            onFastDown()
        }
        TransformationType.Fall -> {
            onFall()
        }
        TransformationType.Rotate -> {
            onRotate()
        }
    }?.finalize() ?: this.finalize()
}
```

ÂØπ‰∫é Left„ÄÅRight„ÄÅDown„ÄÅFastDown„ÄÅFall ËøôÂá†Áßç‰∫ã‰ª∂ÔºåÈÉΩÊòØÂú®ÂØπ offset ÂÅöÊìç‰ΩúÔºåÈÄöËøáÊîπÂèò offset ÁöÑ X ÂùêÊ†áÂíå Y ÂùêÊ†áÊù•ÁßªÂä®ÊñπÂùóÁöÑ‰ΩçÁΩÆ

```kotlin
private fun TetrisState.onLeft(): TetrisState? {
    return copy(
        tetris = tetris.copy(offset = Location(tetris.offset.x - 1, tetris.offset.y))
    ).takeIf { it.isValidInMatrix() }
}

private fun TetrisState.onRight(): TetrisState? {
    return copy(
        tetris = tetris.copy(offset = Location(tetris.offset.x + 1, tetris.offset.y))
    ).takeIf { it.isValidInMatrix() }
}

private fun TetrisState.onDown(): TetrisState? {
    return copy(
        tetris = tetris.copy(
            offset = Location(tetris.offset.x, tetris.offset.y + 1)
        )
    ).takeIf { it.isValidInMatrix() }
}

private fun TetrisState.onFastDown(): TetrisState? {
    return copy(
        tetris = tetris.copy(
            offset = Location(tetris.offset.x, tetris.offset.y + 2)
        )
    ).takeIf { it.isValidInMatrix() }
}

private fun TetrisState.onFall(): TetrisState? {
    while (true) {
        val result = onDown() ?: return this
        return result.onFall()
    }
}
```

ÂâçÊñáËØ¥‰∫ÜÔºåÊØèÁßçÊñπÂùóÁ±ªÂûãÈÉΩÂåÖÂê´ÊúâÂ§öÁßçÊóãËΩ¨ÁªìÊûúÔºåÊâÄ‰ª• Rotate ‰∫ã‰ª∂Â∞±ÈúÄË¶ÅÂ∞ÜÊñπÂùóÊîπÂèò‰∏∫ÂÖ∂ÂÆÉÊóãËΩ¨ÂΩ¢Áä∂„ÄÇËÄåÁî±‰∫éÂΩìÊóãËΩ¨ËøáÂêéÊñπÂùóÁöÑÂùêÊ†áÁ≥ªÂèØËÉΩ‰ºöË∂ÖÂá∫ÂΩìÂâçÂ±èÂπïÁöÑËåÉÂõ¥ÔºåÊâÄ‰ª•ËøòÈúÄË¶Å‰æùÈù† `adjustOffset()`ÊñπÊ≥ïÂ∞ÜÊñπÂùóÁöÑÂùêÊ†áÁ≥ªËøÅÁßªÂõûÂ±èÂπïÂÜÖ

```kotlin
private fun TetrisState.onRotate(): TetrisState? {
    if (tetris.shapes.size == 1) {
        return null
    }
    val nextType = if (tetris.type + 1 < tetris.shapes.size) {
        tetris.type + 1
    } else {
        0
    }
    return copy(
        tetris = tetris.copy(
            type = nextType,
        )
    ).adjustOffset().takeIf { it.isValidInMatrix() }
}
```

ÂΩìÊñπÂùóÊó†Ê≥ïÂÜç‰∏ãËêΩÔºåÊàñËÄÖÊòØÂ∑≤ÁªèË∂ÖÂá∫‰∫ÜÂ±èÂπïÊó∂ÔºåÂàôÈúÄË¶Å‰æùÈù† `finalize()`ÊñπÊ≥ïÂ∞ÜÊñπÂùóÁöÑÂùêÊ†áÂÄºÂÜôÂÖ•Âà∞Â±èÂπïËÉåÊôØ brickArray ‰∏≠ÔºåÂπ∂ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ

```kotlin
private fun TetrisState.finalize(): TetrisState {
    if (canDown()) {
        return this
    } else {
        var gameOver = false
        for (location in tetris.shape) {
            val x = location.x + tetris.offset.x
            val y = location.y + tetris.offset.y
            if (x in 0 until width && y in 0 until height) {
                brickArray[y][x] = 1
            } else {
                gameOver = true
            }
        }
        return if (gameOver) {
            copy(gameStatus = GameStatus.GameOver)
        } else {
            val clearRes = clearIfNeed()
            if (clearRes == null) {
                copy(
                    gameStatus = GameStatus.Running,
                    tetris = nextTetris,
                    nextTetris = Tetris()
                )
            } else {
                copy(
                    gameStatus = GameStatus.LineClearing,
                    tetris = nextTetris,
                    nextTetris = Tetris()
                )
            }
        }
    }
}
```

### È°πÁõÆÂú∞ÂùÄ

Ê∏∏ÊàèÁöÑÂ§ß‰ΩìÂÆûÁé∞ÊÄùË∑ØÂ∞±Â¶Ç‰∏äÊâÄËø∞ÔºåË°®ËææËÉΩÂäõÊâÄÈôêÔºåÊúâ‰∫õÂú∞ÊñπÊ≤°Ê≥ïËÆ≤ÂæóÂ§™Ê∏ÖÊ•öÔºåÂÆûÁé∞ÁªÜËäÇÊ¨¢ËøéÊü•ÈòÖÊ∫êÁ†Å‰∫ÜËß£ üòÇüòÇ

Github Âú∞ÂùÄÔºöhttps://github.com/leavesC/compose-tetris

apk ‰∏ãËΩΩ‰ΩìÈ™åÔºöhttps://github.com/leavesC/compose-tetris/releases/tag/0.0.1